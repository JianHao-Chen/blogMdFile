---
layout: post
title: "栈帧基础知识"
date: 2019-06-21 08:55
comments: false
tags: 
- IO
categories:	
- 基础
- CS
---


写这篇文章是因为，看JVM栈帧部分代码时，需要回顾一下这些基础知识。

<!--more-->

### x86与栈帧
IA32（英特尔32位架构，Intel Architecture 32-bit）,属于复杂指令集系统（CISC）。

#### 寄存器
是CPU计算单元的存储单位，用来保存计算过程中的各种操作数：立即数、整数、存储器引用地址等。

#####  通用寄存器
一个x86 CPU中有8个32位的通用寄存器，它们分别是：
* %eax：一般用作累加器
* %ebx：一般用作基址寄存器（Base）
* %ecx：一般用来计数（Count）
* %edx：一般用来存放数据（Data）
* %ebp：一般用作基址指针（Base Pointer）
* %esp：一般用作堆栈指针（Stack Pointer）
* %edi：一般用作目标变址（Destinatin Index）
* %esi：一般用作源变址（Source Index）

#####  段寄存器
IA32有6个16位的段寄存器，只是这些段寄存器存放的不在是某个段的基地址，而是某个段的选择符（Selector）。因为16位的寄存器无法存放32位的段基地址，段基地址只好放在一个叫段描述符表（Descriptor）的表中。

下面给出 6 个段寄存器的名称和用途：
* CS 代码段寄存器
* DS 数据段寄存器
* SS 堆栈段寄存器
* ES、FS 及 GS 附加数据段寄存器


#### 操作数
多数指令具有一个或多个**操作数**（operand），操作数表示执行该指令要引用的源数据值，和放置指令执行结构的目标数据。 x86 支持3种操作数格式：
* 立即数（immediate），常数
* 寄存器（register），存在于寄存器的值
* 存储器引用，根据某个有效地址访问存储器

#### 寻址模式
**寻址模式**：CPU读取操作数的方式。

以下是 IA-32 寻址模式和操作数格式：

<img src="/assets/blogImg/Frame/1.png" width=400>

####  函数调用
<font color=orange>一个函数调用包括将数据（以函数参数和返回值的形式）和控制从代码的一部分传递到另一部分</font>。数据传递、局部变量的分配和释放是通过操纵程序栈来实现的。

这种控制转移，在编译原理称为**活动记录**，它由3部分组成：
* 被调用者的局部变量
* 返回调用者的地址
* 传入的参数

<img src="/assets/blogImg/Frame/2.png" width=400>

如上图所示，栈用来传递过程参数、存储返回信息、保存寄存器以供后面恢复使用，还有用于本地存储。

<font color=red>栈帧（stack frame）</font>：为单个函数分配的那部分活动记录。

#### 函数调用相关指令介绍

##### call指令
* 目标：指明被调用函数的开始指令地址。
* 效果：将返回地址入栈（就是紧跟着call后面的那一条指令的地址），并跳转到被调用过程的起始处，这样当调用函数返回，执行会继续。

##### ret指令
* 作用：从过程调用中返回，从栈中弹出地址，并跳转到那个位置
 
如果函数要返回整数或指针，寄存器%eax可以用来返回值。

按照惯例，寄存器 %eax、%edx、%ecx被划分为**调用者保存**寄存器，当A调用B时，B可以覆盖这些寄存器，而不会破坏A所需要的数据。寄存器 %ebx、%esi、%di被划分为**被调用者保存**寄存器，即B必须在覆盖它们之前，将这些寄存器的值保存到栈中。


### 寄存器式指令集
许多硬件体系（如x86架构）围绕寄存器存取数据，相应的，寻址方式上也是围绕寄存器设计的，这些指令集称为寄存器式指令集。


###  栈式指令集
指令流中的指令大部分都是零地址指令，它们依赖操作数栈进行工作。

* 优点
  * 可移植
  * 代码更紧凑 -- 字节码中每个字节就对应一条指令，而多地址指令集中还需要存放参数
  * 编译器实现更简单 -- 不需要考虑空间分配的问题，所需空间都在栈上操作
* 缺点
  * 执行速度相对来说会稍慢一些，源于指令数量和内存访问。
