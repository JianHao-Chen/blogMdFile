---
layout: post
title: "IO模型"
date: 2018-02-12 08:55
comments: false
tags: 
- IO
categories:	CS基础
---

### 同步与异步

同步和异步关注的是消息通信机制(synchronous communication / asynchronous communication)。

* <font color=green> **同步:**</font>
在发出一个调用时，在没有得到结果之前，该调用就不返回。但是一旦调用返回，就得到返回值了。换句话说，就是由调用者主动等待这个调用的结果。
* <font color=green> **异步:**</font>
调用在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在调用发出后，被调用者通过状态、通知来通知调用者，或通过回调函数处理这个调用。


### 阻塞与非阻塞
阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态。
* <font color=green> **阻塞:**</font>
调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。
* <font color=green> **非阻塞:**</font>
在不能立刻得到结果之前，该调用不会阻塞当前线程。    


<!--more-->

### 数据流向
一个输入操作通常包括两个不同阶段:
1. 内核等待数据可读
2. 将内核读到的数据拷贝到进程

以套接字上的输入操作为例:
第一步通常涉及等待数据从网络中到达,当所有等待分组到达时，它被复制到内核中的某个缓冲区。
第二步就是把数据从内核缓冲区复制到应用程序缓冲区。 



### 将同步、异步、阻塞、非阻塞分3个层次

#### <font color=red> **CPU层次** </font>
在CPU层次,或者说操作系统进行IO和任务调度的层次,现代操作系统通常使用异步非阻塞方式进行IO,当然有少部分IO可能会使用同步非阻塞轮询。即发出IO请求之后并不等待IO操作完成,而是继续执行下面的指令（非阻塞），IO操作和CPU指令互不干扰（异步）.最后通过中断的方式来通知IO操作完成结果。

#### <font color=red> **线程层次** </font>
在线程层次，或者说操作系统调度单元的层次，操作系统为了减轻程序员的思考负担，将底层的异步非阻塞的IO方式进行封装，把相关系统调用（如read，write等）以同步的方式展现出来。然而，同步阻塞的IO会使线程挂起，同步非阻塞的IO会消耗CPU资源在轮询上。为了解决这一问题，就有3种思路: 
* 多线程（同步阻塞）
* IO多路复用（select，poll，epoll）（同步非阻塞，严格地来讲，是把阻塞点改变了位置）
* 直接暴露出异步的IO接口，如kernel-aio和IOCP（异步非阻塞）

#### <font color=red> **程序员感知层次** </font>
在Linux中，上面提到的第2种思路用得比较广泛，也是比较理想的解决方案。然而，直接使用select之类的接口，依然比较复杂，所以各种库和框架百花齐放，都试图对IO多路复用进行封装。此时，库和框架提供的API又可以选择是以同步的方式还是异步的方式来展现。如python的asyncio库中，就通过协程，提供了同步阻塞式的API；如node.js中，就通过回调函数，提供了异步非阻塞式的API。


### Unix/Linux 下的几种IO模型

#### <font color=pink> **同步阻塞IO** </font>
同步阻塞IO模型是最简单的IO模型，用户线程在内核进行IO操作时被阻塞。用户线程通过系统调用read发起IO读操作，由用户空间转到内核空间。内核等到数据包到达后，然后将接收的数据拷贝到用户空间，完成read操作。即用户需要等待read将socket中的数据读取到buffer后，才继续处理接收的数据。整个IO请求的过程中，用户线程是被阻塞的，这导致用户在发起IO请求时，不能做任何事情。

用户线程使用同步阻塞IO模型的伪代码描述为:
```bash
...
read(socket, buffer);
process(buffer);

```

#### <font color=pink> **同步非阻塞IO** </font>
同步非阻塞IO是在同步阻塞IO的基础上，将socket设置为NONBLOCK。这样做用户线程可以在发起IO请求后可以立即返回。由于socket是非阻塞的方式，因此用户线程发起IO请求时立即返回。但并未读取到任何数据，用户线程需要不断地发起IO请求，直到数据到达后，才真正读取到数据，继续执行。 即用户需要不断地调用read，尝试读取socket中的数据，直到读取成功后，才继续处理接收的数据。整个IO请求的过程中，虽然用户线程每次发起IO请求后可以立即返回，但是为了等到数据，仍需要不断地轮询、重复请求，消耗了大量的CPU的资源。一般很少直接使用这种模型，而是在其他IO模型中使用非阻塞IO这一特性。

用户线程使用同步非阻塞IO模型的伪代码描述为:
```bash
...
while(read(socket, buffer) != SUCCESS)
  ;
process(buffer);

```

#### <font color=pink> **IO多路复用** </font>
IO多路复用模型是建立在内核提供的多路分离函数select基础之上的，使用select函数可以避免同步非阻塞IO模型中轮询等待的问题。使用select以后最大的优势是用户可以在一个线程内同时处理多个socket的IO请求。用户可以注册多个socket，然后不断地调用select读取被激活的socket，即可达到在同一个线程内同时处理多个IO请求的目的。而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的。

用户线程使用select函数的伪代码描述为:
```bash
...
sockets = select();
for(socket in sockets) {
  read(socket, buffer);
  process(buffer);
}
```

#### <font color=pink> **异步IO** </font>
当用户线程收到通知时，数据已经被内核读取完毕，并放在了用户线程指定的缓冲区内，内核在IO完成后通知用户线程直接使用即可。