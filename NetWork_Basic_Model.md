---
layout: post
title: "网络模型分层"
date: 2019-04-01 08:55
comments: false
tags: 
- 网络
categories:	
- 基础
- 网络
---

### 五层模型
把互联网分成五层，比较容易解释：

```
 ------------------------------
 | 应用层（Application Layer） |
 -------------------------------
 | 传输层（Transport Layer）   |
 -------------------------------
 | 网络层（Network Layer）     |
 -------------------------------
 | 链接层（Link Layer）        |
 -------------------------------
 | 物理层（Physical Layer）    |
 -------------------------------
```
下面介绍每一层的功能，主要就是介绍每一层的主要协议。

<!--more-->


#### 物理层（Physical Layer）
**物理层**负责规定网络连接的物理电气特性，即负责传送0和1的电信号。

因此，电脑之间的连接，可以通过光缆、电缆、双绞线、无线电波等方式，只要这些光缆、电缆是符合规定的。

#### 链接层（Link Layer） 
##### 定义
单纯的0和1没有任何意义，必须规定解读方式：多少个电信号算一组？每个信号位有何意义？
这就是"链接层"的功能，它在"实体层"的上方，确定了0和1的分组方式。

##### 以太网协议
早期的时候，每家公司都有自己的电信号分组方式。逐渐地，一种叫做"以太网"（Ethernet）的协议，占据了主导地位。
以太网规定，一组电信号构成一个数据包，叫做"帧"（Frame）。每一帧分成两个部分：标头（Head）和数据（Data）。
```
 -------------------------------
 |   Head   |        Data      |
 -------------------------------
```

* 标头（Head）固定14字节：目的地址（6）+ 源地址（6）+ 类型（2）
* 数据（Data）最少46字节，最多1500字节
* 整个帧的大小为：60 ~ 1514 字节

##### MAC地址
上面提到“标头”的源、目的地址，都是**MAC地址**！
每块网卡出厂的时候，都有一个全世界独一无二的MAC地址，长度是48个二进制位，通常用12个十六进制数表示。前6个十六进制数是厂商编号，后6个是该厂商的网卡流水号。

##### 广播
在**链接层**数据包的传递是通过**广播**的：
* 通过将源、目的地址的MAC地址填入帧的标头，发送数据包。
* 当前以太网的机器都收到这个数据包，但是只有MAC地址对应的机器才会接收，其他机器会丢弃这个包。

如何其他机器的MAC地址：通过**ARP协议**。

#### 网络层（Network Layer） 

##### 网络层的由来
互联网是一个由无数子网络共同组成的巨型网络，协议层只能解决同一子网络的通信，于是我们需要一个方法跨子网络的通信。
**网络层**出现了，它的作用是：<font color=orange>引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做"网络地址"，简称"网址"</font>。


##### IP协议
* IP协议：规定网络地址的协议
* IP地址：IP协议所定义的地址。目前广泛采用的是IP协议第四版，简称IPv4。
* 子网掩码：用于判断IP地址是否处于同一子网：它在形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。
  
##### IP数据包
IP数据包包含 Header、Data 2部分：
```
 -------------------------------
 |   Head   |        Data      |
 -------------------------------
```
Header 主要有：版本、长度、IP地址等信息。
放入以太网数据包后，以太网数据包就变成了下面这样：
```
------------------------------------------
|   Head   |   Head   |        Data      |
------------------------------------------
```

IP数据包总长度：最大为 65,535 字节
* Head部分：20 ~ 60 字节
* Data部分：最长为 65,515 字节

前面说过，以太网数据包的"数据"部分，最长只有1500字节。因此，如果IP数据包超过了1500字节，它就需要分割成几个以太网数据包，分开发送了。

#### 传输层（Transport Layer） 
##### 传输层的由来
"网络层"的功能是建立"主机到主机"的通信。"传输层"的功能，就是建立"端口到端口"的通信。
只要确定主机和端口，我们就能实现程序之间的交流。因此，Unix系统就把主机+端口，叫做"套接字"（socket）。有了它，就可以进行网络应用程序开发了。

##### UDP协议
UDP数据包，也是由"标头"和"数据"两部分组成：
```
 -------------------------------
 |   Head   |        Data      |
 -------------------------------
```

"标头"部分主要定义了**发出端口**和**接收端口**，"数据"部分就是具体的内容。把整个UDP数据包放入IP数据包的"数据"部分，而前面说过，IP数据包又是放在以太网数据包之中的，所以整个以太网数据包现在变成了下面这样：
```
-----------------------------------------------------
|   Head   |   Head   |   Head   |        Data      |
-----------------------------------------------------
```
UDP数据包非常简单，"标头"部分一共只有8个字节，总长度不超过65,535字节，正好放进一个IP数据包。

##### TCP协议
TCP数据包和UDP数据包一样，都是内嵌在IP数据包的"数据"部分。TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。

#### 应用层（Application Layer）
应用程序收到"传输层"的数据，接下来就要进行解读。由于互联网是开放架构，数据来源五花八门，必须事先规定好格式，否则根本无法解读。"应用层"的作用，就是规定应用程序的数据格式。


### 一个访问网页的实例

#### 本机参数
假定一个用户使用如下网络参数：
* 本机的IP地址：192.168.1.100
* 子网掩码：255.255.255.0
* 网关的IP地址：192.168.1.1
* DNS的IP地址：8.8.8.8

然后访问：`www.google.com`，于是浏览器向Google发送一个网页请求的数据包。

#### DNS协议
我们知道，发送数据包，必须要知道对方的IP地址。但是，现在，我们只知道网址 `www.google.com`，不知道它的IP地址。DNS协议可以帮助我们，将这个网址转换成IP地址。已知DNS服务器为8.8.8.8，于是我们向这个地址发送一个DNS数据包（53端口）。
然后，DNS服务器做出响应，告诉我们Google的IP地址是172.194.72.105。于是，我们知道了对方的IP地址。

#### 子网掩码
接下来，我们要判断，这个IP地址是不是在同一个子网络，这就要用到子网掩码。
已知子网掩码是255.255.255.0，本机用它对自己的IP地址192.168.1.100，做一个二进制的AND运算（两个数位都为1，结果为1，否则为0），计算结果为192.168.1.0；然后对Google的IP地址172.194.72.105也做一个AND运算，计算结果为172.194.72.0。这两个结果不相等，所以结论是，Google与本机不在同一个子网络。
因此，我们要向Google发送数据包，必须通过网关192.168.1.1转发，也就是说，接收方的MAC地址将是网关的MAC地址。

#### 应用层协议
浏览网页用的是HTTP协议，它的整个数据包构造是这样的：
<img height=200 src="/assets/blogImg/NetWork_Basic/Model/1.png">

HTTP部分的内容，类似于下面这样：
```
GET / HTTP/1.1
Host: [url=http://www.google.com]www.google.com[/url]
Connection: keep-alive
User-Agent: Mozilla/5.0 (Windows NT 6.1) ......
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Encoding: gzip,deflate,sdch
Accept-Language: zh-CN,zh;q=0.8
Accept-Charset: GBK,utf-8;q=0.7,*;q=0.3
Cookie: ... ...
```

我们假定这个部分的长度为4960字节，它会被嵌在TCP数据包之中。

#### TCP协议
TCP数据包需要设置端口，接收方（Google）的HTTP端口默认是80，发送方（本机）的端口是一个随机生成的1024-65535之间的整数，假定为51775。TCP数据包的标头长度为20字节，加上嵌入HTTP的数据包，总长度变为4980字节。

#### IP协议
然后，TCP数据包再嵌入IP数据包。IP数据包需要设置双方的IP地址，这是已知的，发送方是192.168.1.100（本机），接收方是172.194.72.105（Google）。IP数据包的标头长度为20字节，加上嵌入的TCP数据包，总长度变为5000字节。

#### 以太网协议
最后，IP数据包嵌入以太网数据包。以太网数据包需要设置双方的MAC地址，发送方为本机的网卡MAC地址，接收方为网关192.168.1.1的MAC地址（通过ARP协议得到）。

以太网数据包的数据部分，最大长度为1500字节，而现在的IP数据包长度为5000字节。因此，IP数据包必须分割成四个包。因为每个包都有自己的IP标头（20字节），所以四个包的IP数据包的长度分别为1500、1500、1500、560。

<img height=600 src="/assets/blogImg/NetWork_Basic/Model/2.png">

#### 服务器端响应
经过多个网关的转发，Google的服务器172.194.72.105，收到了这四个以太网数据包。根据IP标头的序号，Google将四个包拼起来，取出完整的TCP数据包，然后读出里面的"HTTP请求"，接着做出"HTTP响应"，再用TCP协议发回来。

本机收到HTTP响应以后，就可以将网页显示出来，完成一次网络通信。

### 网络设备简介

#### 集线器（Hub）
集线器起到了一个将网线集结起来的作用，实现最初级的网络互通。
集线器是通过网线直接传送数据的，我们说他工作在**物理层**。

集线器有一个问题，由于和每台设备相连，他不能分辨出具体信息是发送给谁的，只能广泛地广播出去。

#### 交换机
交换机根据网口地址传送信息，实现了（同一子网内）任意两台电脑间的互联，大大地提升了网络间的传输速度。
我们说交换机工作**在数据链路层**。

#### 路由器
路由器通过IP地址寻址，我们说它工作在**网络层**。


### 总结
* 物理层：电路信号的控制、电压范围控制等；
* 链路层：实现子网内部的机器间通信
* 网络层：实现跨子网的机器之间的通信
* 传输层：实现程序之间的通信
* 应用层：负责与用户交互。